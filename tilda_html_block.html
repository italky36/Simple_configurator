<script>
  (function () {
    // Укажите ваш реальный адрес API
    const API_BASE = 'https://93-170-123-229.nip.io/api';
    
    let META = null;
    let currentVariationId = null;
    let currentSlideIndex = 0;

    function getEl(id) { return document.getElementById(id); }

    // =========================================================
    // 1. ЛОГИКА МОДАЛЬНОГО ОКНА И ОТПРАВКИ ФОРМЫ
    // =========================================================
    const modal = getEl('invoice-modal');
    const btnOpen = getEl('btn-invoice');
    const btnCloseX = getEl('modal-close-x');
    const btnCancel = getEl('modal-cancel-btn');
    const form = getEl('invoice-form');

    function openModal() { modal.classList.add('is-open'); }
    function closeModal() { modal.classList.remove('is-open'); }

    if (btnOpen) btnOpen.addEventListener('click', openModal);
    if (btnCloseX) btnCloseX.addEventListener('click', closeModal);
    if (btnCancel) btnCancel.addEventListener('click', closeModal);
    
    // Закрытие по клику на затемненный фон
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
      });
    }

    // --- САМОЕ ВАЖНОЕ: ОТПРАВКА ДАННЫХ ---
    if (form) {
      form.addEventListener('submit', async (e) => {
        e.preventDefault(); // Останавливаем перезагрузку страницы
        
        const formData = new FormData(form);
        const submitBtn = form.querySelector('.cz-btn-submit');
        const originalText = submitBtn.textContent;
        
        // Блокируем кнопку, чтобы не нажали дважды
        submitBtn.disabled = true;
        submitBtn.textContent = 'Отправка...';

        // Вспомогательная функция: получить текст выбранного пункта
        const getSelectText = (id) => {
          const el = getEl(id);
          if (el && el.selectedIndex >= 0) return el.options[el.selectedIndex].text;
          return null;
        };

        // Собираем данные о том, что выбрал пользователь в конфигураторе
        const selectionData = {
          machine: getSelectText('machine-select'),
          frame: getSelectText('carcass-select'),
          frame_color: getSelectText('carcass-color-select'),
          refrigerator: getSelectText('fridge-select'),
          terminal: getSelectText('terminal-select'),
          price: getEl('price-regular')?.textContent || '-',
          ozon_link: getEl('btn-ozon')?.disabled ? null : (currentVariationId ? 'Есть ссылка' : null),
          gallery_folder: currentVariationId ? ('Variation ID: ' + currentVariationId) : 'Не выбрано'
        };

        // Формируем итоговый объект для Python
        const payload = {
          name: formData.get('name'),
          phone: formData.get('phone'),
          telegram: formData.get('telegram'),
          email: formData.get('email'),
          selection: selectionData // Вкладываем конфигурацию
        };

        try {
          const res = await fetch(API_BASE + '/lead', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (res.ok) {
            alert('Спасибо! Ваша заявка отправлена.');
            closeModal();
            form.reset(); // Очищаем поля формы
          } else {
            const errData = await res.json().catch(() => ({}));
            alert('Ошибка при отправке: ' + (errData.detail || 'Попробуйте позже.'));
          }
        } catch (err) {
          console.error(err);
          alert('Ошибка соединения с сервером.');
        } finally {
          // Возвращаем кнопку в исходное состояние
          submitBtn.disabled = false;
          submitBtn.textContent = originalText;
        }
      });
    }

    // =========================================================
    // 2. ЛОГИКА КОНФИГУРАТОРА (Слайдер, API, Цены)
    // =========================================================

    async function fetchJson(url) {
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      if (!res.ok) throw new Error('API error ' + res.status);
      return res.json();
    }

    function getIntValue(id) {
      const el = getEl(id);
      if (!el) return null;
      const v = el.value;
      if (v === '' || v == null) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function saveState() {
      const state = {
        machineId: getEl('machine-select')?.value || '',
        fridgeId: getEl('fridge-select')?.value || '',
        terminalId: getEl('terminal-select')?.value || '',
        carcassId: getEl('carcass-select')?.value || '',
        carcassColorId: getEl('carcass-color-select')?.value || '',
        designColorId: getEl('design-color-select')?.value || ''
      };
      try { localStorage.setItem('configurator-state', JSON.stringify(state)); } catch (e) {}
    }

    function restoreState() {
      try { return JSON.parse(localStorage.getItem('configurator-state')); } catch (e) { return null; }
    }

    function fillSelect(select, items, mapFn) {
      if (!select) return;
      select.innerHTML = '';
      items.forEach(item => {
        const { value, label } = mapFn(item);
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = label;
        select.appendChild(opt);
      });
    }

    function uniqueById(arr) {
      const map = new Map();
      arr.forEach(item => {
        if (!item || item.id == null) return;
        if (!map.has(item.id)) map.set(item.id, item);
      });
      return Array.from(map.values());
    }

    function findCarcass(id) {
      return (META?.carcasses || []).find(c => c.id === id) || null;
    }

    function setOzonPlaceholder() {
      const priceSaleEl = getEl('price-sale');
      if (!priceSaleEl) return;
      priceSaleEl.innerHTML =
        '<span class="price-placeholder">' +
          '<span class="price-placeholder__icon">ⓘ</span>' +
          '<span class="price-placeholder__text">Нет комплекта OZON</span>' +
        '</span>';
    }

    function updateCarcassColorsAndDesigns() {
      const carcassColorSelect = getEl('carcass-color-select');
      const designColorSelect  = getEl('design-color-select');
      if (!META || !carcassColorSelect || !designColorSelect) return;

      const carcassId = getIntValue('carcass-select');

      if (!carcassId) {
        carcassColorSelect.innerHTML = ''; designColorSelect.innerHTML = '';
        carcassColorSelect.disabled = true; designColorSelect.disabled = true;
        return;
      }

      const carcass = findCarcass(carcassId);
      if (!carcass || !Array.isArray(carcass.variations)) {
        carcassColorSelect.innerHTML = ''; designColorSelect.innerHTML = '';
        carcassColorSelect.disabled = true; designColorSelect.disabled = true;
        return;
      }

      const variations = carcass.variations;
      const carcassColors = uniqueById(variations.map(v => v.carcass_color));

      carcassColorSelect.disabled = false;
      // designColorSelect пока блокируем, пока не выберут цвет каркаса
      
      fillSelect(carcassColorSelect, carcassColors, c => ({
        value: c.id, label: c.name || c.code
      }));

      // Сразу обновляем доступные цвета дизайна для первого цвета каркаса
      updateDesignColors();
    }

    function updateDesignColors() {
      const designColorSelect = getEl('design-color-select');
      if (!META || !designColorSelect) return;
      const carcassId = getIntValue('carcass-select');
      const carcassColorId = getIntValue('carcass-color-select');

      if (!carcassId || !carcassColorId) {
        designColorSelect.innerHTML = ''; designColorSelect.disabled = true; return;
      }

      const carcass = findCarcass(carcassId);
      if (!carcass || !Array.isArray(carcass.variations)) return;

      const variations = carcass.variations.filter(v => v.carcass_color?.id === carcassColorId);
      const designColors = uniqueById(variations.map(v => v.design_color));

      designColorSelect.disabled = false;
      fillSelect(designColorSelect, designColors, c => ({
        value: c.id, label: c.name || c.code
      }));
    }

    function getTerminalOptions() {
      return [{ id: '', name: 'Нет' }].concat(META?.terminals || []);
    }

    function updateTerminalAvailability() {
      const terminalSelect = getEl('terminal-select');
      if (!terminalSelect) return;
      const machineId = getIntValue('machine-select');
      
      if (!machineId) {
        terminalSelect.dataset.prevTerminal = terminalSelect.value || '';
        terminalSelect.innerHTML = '';
        terminalSelect.disabled = true;
        return;
      }

      // Если включили машину, разблокируем терминал
      terminalSelect.disabled = false;
      
      // Если список пуст (был очищен), заполняем заново
      if (terminalSelect.options.length === 0) {
          fillSelect(terminalSelect, getTerminalOptions(), t => ({
            value: t.id, label: t.name
          }));
      }

      const prev = terminalSelect.dataset.prevTerminal;
      if (prev) {
        const hasPrev = Array.from(terminalSelect.options).some(opt => opt.value == prev);
        if (hasPrev) terminalSelect.value = prev;
      }
    }

    function getActiveCarcassVariation() {
      const carcassId = getIntValue('carcass-select');
      if (!carcassId) return null;
      const carcassColorId = getIntValue('carcass-color-select');
      const designColorId  = getIntValue('design-color-select');
      const carcass = findCarcass(carcassId);
      if (!carcass || !Array.isArray(carcass.variations)) return null;

      let variation = carcass.variations.find(v =>
        v.carcass_color?.id === carcassColorId && v.design_color?.id === designColorId
      );
      // Если точного совпадения нет, берем первую вариацию (fallback)
      if (!variation) variation = carcass.variations[0] || null;
      return variation || null;
    }

    function updateSliderPosition() {
      const track = document.getElementById('slider-track');
      if (!track || track.children.length <= 0) return;
      const total = track.children.length;
      if (currentSlideIndex < 0) currentSlideIndex = 0;
      if (currentSlideIndex > total - 1) currentSlideIndex = total - 1;
      track.style.transform = 'translateX(-' + (currentSlideIndex * 100) + '%)';
    }

    function renderGallery(variation) {
      const trackEl = document.getElementById('slider-track');
      if (!trackEl) return;
      
      // Удаляем все слайды кроме первого (интерактивного)
      // Предполагаем, что интерактивный слайд всегда первый
      while (trackEl.children.length > 1) { trackEl.removeChild(trackEl.lastChild); }

      const urls = variation?.gallery_image_urls || [];
      const carcassId = getIntValue('carcass-select');
      const hasFrame = !!carcassId;
      const hasAnyItem = !!(getIntValue('machine-select') || getIntValue('fridge-select') || getIntValue('terminal-select'));

      // Добавляем картинки из галереи
      urls.forEach(url => {
        const slide = document.createElement('div');
        slide.className = 'slider-slide';
        const img = document.createElement('img');
        img.src = url; img.loading = 'lazy';
        img.style.width = '100%'; img.style.height = 'auto'; img.style.maxWidth = '400px';
        slide.appendChild(img);
        trackEl.appendChild(slide);
      });
      
      // Если выбран каркас и товары, добавляем "превью сборки" в конец галереи
      if (hasFrame && hasAnyItem) {
        const original = document.getElementById('config-layers');
        if (original) {
          const slide = document.createElement('div');
          slide.className = 'slider-slide';
          const clone = original.cloneNode(true);
          clone.removeAttribute('id');
          clone.querySelectorAll('[id]').forEach(node => node.removeAttribute('id'));
          clone.classList.add('config-layers-preview');
          slide.appendChild(clone);
          trackEl.appendChild(slide);
        }
      }
      currentSlideIndex = 0;
      updateSliderPosition();
    }

    function updateLayers() {
      if (!META) return;
      const machineId  = getIntValue('machine-select');
      const fridgeId   = getIntValue('fridge-select');
      const terminalId = getIntValue('terminal-select');
      const carcassId  = getIntValue('carcass-select');

      const machine  = (META.machines  || []).find(m => m.id === machineId);
      const fridge   = (META.fridges   || []).find(f => f.id === fridgeId);
      const terminal = (META.terminals || []).find(t => t.id === terminalId);
      const carcass  = findCarcass(carcassId);

      const variation = getActiveCarcassVariation();
      currentVariationId = variation ? variation.id : null;

      const layerCarcass = getEl('layer-carcass');
      const layerFridge  = getEl('layer-fridge');
      const layerMachine = getEl('layer-machine');
      const layerTerminal = getEl('layer-terminal');
      const configLayers = getEl('config-layers');
      const productImage = document.querySelector('.cz-conf .product-image');
      const itemsContainer = document.querySelector('.cz-conf .items-container');
      const emptyState = getEl('empty-state');

      if (layerCarcass) layerCarcass.src = variation?.main_image_url || '';
      
      if (layerFridge) {
        layerFridge.src = fridge?.main_image_url || '';
        layerFridge.classList.toggle('is-active', !!fridge);
      }
      if (layerMachine) {
        layerMachine.src = machine?.main_image_url || '';
        layerMachine.classList.toggle('is-active', !!machine);
      }
      if (layerTerminal) {
        layerTerminal.src = terminal?.main_image_url || '';
        layerTerminal.classList.toggle('is-active', !!terminal);
      }

      const hasFrame = !!carcassId;
      const hasCoffee = !!machineId;
      const hasFridge = !!fridgeId;
      const hasTerminal = !!terminalId;

      const elementCount = (hasCoffee ? 1 : 0) + (hasFridge ? 1 : 0) + (hasTerminal ? 1 : 0);
      const nothingSelected = !hasFrame && !hasCoffee && !hasFridge && !hasTerminal;

      if (configLayers) {
        configLayers.classList.toggle('carcass-selected', hasFrame);
        configLayers.classList.toggle('no-frame', !hasFrame && elementCount > 0);
        configLayers.classList.toggle('frame-only', hasFrame && elementCount === 0);
      }

      if (productImage) {
         if (hasFrame) productImage.classList.add('carcass-active');
         else productImage.classList.remove('carcass-active');
      }

      if (emptyState) emptyState.style.display = nothingSelected ? 'flex' : 'none';

      if (itemsContainer) {
        const isBusinessCarcass = !!carcass && typeof carcass.name === 'string' && carcass.name.toLowerCase().includes('coffee zone business');
        
        // Сброс классов лейаута
        itemsContainer.className = 'items-container'; 
        if (isBusinessCarcass && hasFrame) itemsContainer.classList.add('carcass-business');

        if (nothingSelected) {
          renderGallery(variation);
          return;
        }

        if (hasFrame && elementCount > 0) {
             if (elementCount === 1) {
               if (hasCoffee) itemsContainer.classList.add('layout-frame-coffee-only');
               else if (hasFridge) itemsContainer.classList.add('layout-frame-fridge-only');
               else if (hasTerminal) itemsContainer.classList.add('layout-frame-terminal-only');
             }
        } else if (!hasFrame && elementCount > 0) {
             if (elementCount === 1) {
               if (hasCoffee) itemsContainer.classList.add('layout-alone-coffee');
               else if (hasFridge) itemsContainer.classList.add('layout-alone-fridge');
               else if (hasTerminal) itemsContainer.classList.add('layout-alone-terminal');
             } else if (elementCount === 2) {
               if (hasCoffee && hasFridge) itemsContainer.classList.add('layout-pair-coffee-fridge');
               else if (hasCoffee && hasTerminal) itemsContainer.classList.add('layout-pair-coffee-terminal');
               else if (hasFridge && hasTerminal) itemsContainer.classList.add('layout-pair-fridge-terminal');
             } else if (elementCount === 3) {
               itemsContainer.classList.add('layout-trio-all');
             }
        }
        void itemsContainer.offsetHeight; // force reflow
      }

      renderGallery(variation);
    }

    function renderSpecs() {
      const container = getEl('specs-container');
      if (!container || !META) return;
      container.innerHTML = '';

      const machineId  = getIntValue('machine-select');
      const fridgeId   = getIntValue('fridge-select');
      const terminalId = getIntValue('terminal-select');
      const carcassId  = getIntValue('carcass-select');

      const machine  = (META.machines  || []).find(m => m.id === machineId);
      const fridge   = (META.fridges   || []).find(f => f.id === fridgeId);
      const terminal = (META.terminals || []).find(t => t.id === terminalId);
      const carcass  = findCarcass(carcassId);

      const blocks = [
        { title: 'Кофемашина', item: machine },
        { title: 'Холодильник', item: fridge },
        { title: 'Каркас', item: carcass },
        { title: 'Терминал', item: terminal }
      ];

      blocks.forEach(({ title, item }) => {
        if (!item || item.id == null) return;
        const block = document.createElement('div');
        block.className = 'spec-block';
        
        const t = document.createElement('div');
        t.className = 'spec-title';
        t.textContent = title;
        block.appendChild(t);

        const nameDiv = document.createElement('div');
        nameDiv.className = 'spec-name';
        nameDiv.textContent = item.name || '';
        block.appendChild(nameDiv);

        const specs = item.specs_short || item.specs || null;
        if (Array.isArray(specs) && specs.length) {
          const ul = document.createElement('ul');
          ul.className = 'spec-list';
          specs.forEach(s => {
            const li = document.createElement('li');
            li.textContent = s;
            ul.appendChild(li);
          });
          block.appendChild(ul);
        }
        container.appendChild(block);
      });
    }

    async function updatePreview() {
      if (!META) return;
      const coffee_machine_id = getIntValue('machine-select');
      const fridge_id         = getIntValue('fridge-select');
      const carcass_id        = getIntValue('carcass-select');
      const carcass_color_id  = getIntValue('carcass-color-select');
      const design_color_id   = getIntValue('design-color-select');
      const terminal_id       = getIntValue('terminal-select');

      const priceSaleEl    = getEl('price-sale');
      const priceRegularEl = getEl('price-regular');
      const btnOzon        = getEl('btn-ozon');

      // Локальный расчет "Обычной цены" (сумма компонентов)
      let basePrice = 0;
      function addPrice(item) { if (item && typeof item.price === 'number') basePrice += item.price; }

      const machine  = (META.machines  || []).find(m => m.id === coffee_machine_id);
      const fridge   = (META.fridges   || []).find(f => f.id === fridge_id);
      const terminal = (META.terminals || []).find(t => t.id === terminal_id);
      const carcass  = findCarcass(carcass_id);

      addPrice(machine); addPrice(fridge); addPrice(terminal); addPrice(carcass);

      if (priceRegularEl) {
        if (basePrice > 0) {
          priceRegularEl.classList.add('updating');
          priceRegularEl.textContent = basePrice.toLocaleString('ru-RU') + '₽';
          setTimeout(() => priceRegularEl.classList.remove('updating'), 400);
        } else {
          priceRegularEl.textContent = '';
        }
      }

      // Если конфигурация неполная для каркаса, то OZON не считаем
      if (!coffee_machine_id || !carcass_id || !carcass_color_id || !design_color_id) {
        if (priceSaleEl) setOzonPlaceholder();
        if (btnOzon) { btnOzon.disabled = true; btnOzon.removeAttribute('onclick'); }
        return;
      }

      // Запрос цены OZON и ссылки
      const params = new URLSearchParams();
      params.set('coffee_machine_id', coffee_machine_id);
      params.set('carcass_id',        carcass_id);
      params.set('carcass_color_id',  carcass_color_id);
      params.set('design_color_id',   design_color_id);
      if (fridge_id)   params.set('fridge_id', fridge_id);
      if (terminal_id) params.set('terminal_id', terminal_id);
      if (currentVariationId) params.set('carcass_design_combination_id', currentVariationId);

      let preview;
      try {
        preview = await fetchJson(API_BASE + '/preview?' + params.toString());
      } catch (e) {
        console.error('preview error', e);
        return;
      }

      if (!preview || !preview.is_exact_bundle) {
        if (priceSaleEl) setOzonPlaceholder();
        if (btnOzon) { btnOzon.disabled = true; btnOzon.removeAttribute('onclick'); }
        return;
      }

      if (priceSaleEl && preview.custom_price != null) {
        priceSaleEl.classList.add('updating');
        priceSaleEl.textContent = preview.custom_price.toLocaleString('ru-RU') + '₽';
        setTimeout(() => priceSaleEl.classList.remove('updating'), 400);
      }

      if (btnOzon) {
        if (preview.ozon_url) {
          btnOzon.disabled = false;
          btnOzon.textContent = 'Заказать на OZON';
          btnOzon.onclick = function () { window.open(preview.ozon_url, '_blank'); };
        } else {
          btnOzon.disabled = true;
          btnOzon.textContent = 'Нет ссылки OZON';
          btnOzon.removeAttribute('onclick');
        }
      }
    }

    async function init() {
      try {
        META = await fetchJson(API_BASE + '/meta');
      } catch (e) {
        console.error('Failed to load /meta', e);
        return;
      }

      const machinesSelect  = getEl('machine-select');
      const fridgesSelect   = getEl('fridge-select');
      const terminalsSelect = getEl('terminal-select');
      const carcassesSelect = getEl('carcass-select');

      const savedState = restoreState();

      // Заполнение селектов
      if (machinesSelect) {
        const items = [{ id: '', name: 'Нет' }].concat(META.machines || []);
        fillSelect(machinesSelect, items, m => ({ value: m.id, label: m.name }));
        if (savedState?.machineId) machinesSelect.value = savedState.machineId;
        else if (META.machines && META.machines.length) machinesSelect.value = META.machines[0].id;
      }

      if (fridgesSelect) {
        const items = [{ id: '', name: 'Нет' }].concat(META.fridges || []);
        fillSelect(fridgesSelect, items, f => ({ value: f.id, label: f.name }));
        if (savedState?.fridgeId) fridgesSelect.value = savedState.fridgeId;
        else if (META.fridges && META.fridges.length) fridgesSelect.value = META.fridges[0].id;
      }

      if (terminalsSelect) {
        const items = [{ id: '', name: 'Нет' }].concat(META.terminals || []);
        fillSelect(terminalsSelect, items, t => ({ value: t.id, label: t.name }));
        if (savedState?.terminalId) terminalsSelect.value = savedState.terminalId;
        else if (META.terminals && META.terminals.length) terminalsSelect.value = META.terminals[0].id;
      }

      if (carcassesSelect) {
        const items = [{ id: '', name: 'Нет' }].concat(META.carcasses || []);
        fillSelect(carcassesSelect, items, c => ({ value: c.id, label: c.name }));
        if (savedState?.carcassId) carcassesSelect.value = savedState.carcassId;
        else if (META.carcasses && META.carcasses.length) carcassesSelect.value = META.carcasses[0].id;
      }

      updateCarcassColorsAndDesigns();
      updateTerminalAvailability();
      
      // Попытка восстановить сложные зависимости (цвета) из LocalStorage
      if (savedState?.carcassId && (savedState.carcassColorId || savedState.designColorId)) {
        requestAnimationFrame(() => {
          const carcassColorSelect = getEl('carcass-color-select');
          const designColorSelect = getEl('design-color-select');
          
          if (carcassColorSelect && savedState.carcassColorId) {
             // Проверяем, есть ли такая опция
             const hasOp = Array.from(carcassColorSelect.options).some(o => o.value == savedState.carcassColorId);
             if (hasOp) {
               carcassColorSelect.value = savedState.carcassColorId;
               updateDesignColors();
               
               requestAnimationFrame(() => {
                 if (designColorSelect && savedState.designColorId) {
                    const hasD = Array.from(designColorSelect.options).some(o => o.value == savedState.designColorId);
                    if (hasD) designColorSelect.value = savedState.designColorId;
                 }
                 updateLayers(); renderSpecs(); updatePreview();
               });
             } else {
               updateLayers(); renderSpecs(); updatePreview();
             }
          } else {
             updateLayers(); renderSpecs(); updatePreview();
          }
        });
      } else {
        updateLayers();
        renderSpecs();
        await updatePreview();
      }
      
      attachEvents();
    }

    function attachEvents() {
      const ids = [
        'machine-select', 'fridge-select', 'terminal-select',
        'carcass-select', 'carcass-color-select', 'design-color-select'
      ];

      ids.forEach(id => {
        const el = getEl(id);
        if (!el) return;
        el.addEventListener('change', async () => {
          if (id === 'carcass-select') updateCarcassColorsAndDesigns();
          else if (id === 'carcass-color-select') updateDesignColors();
          else if (id === 'machine-select') updateTerminalAvailability();
          
          updateLayers();
          renderSpecs();
          await updatePreview();
          saveState();
        });
      });

      const arrowLeft = document.querySelector('.cz-conf .arrow-left');
      const arrowRight = document.querySelector('.cz-conf .arrow-right');
      
      if (arrowLeft) {
        arrowLeft.addEventListener('click', () => {
          currentSlideIndex -= 1;
          updateSliderPosition();
        });
      }
      if (arrowRight) {
        arrowRight.addEventListener('click', () => {
          currentSlideIndex += 1;
          updateSliderPosition();
        });
      }
    }

    document.addEventListener('DOMContentLoaded', init);
  })();
</script>
